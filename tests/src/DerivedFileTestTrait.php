<?php
/**
 * Copyright Â© 2012 - 2021 by Renaud Guillard (dev@nore.fr)
 * Distributed under the terms of the MIT License, see LICENSE
 *
 * @package Core
 */
namespace NoreSources\Test;

/**
 * File generation utility and assertions
 *
 * This trait should be used in PHPUnit TestCase to check generated file content agains existing
 * file.
 */
trait DerivedFileTestTrait
{

	/**
	 * Initialize directories location
	 * Should be called in TestCase constructor or setUp function
	 *
	 * @param string $basePath
	 *        	Derived and reference base directory
	 * @param string $referenceDirectory
	 *        	Reference files directory
	 * @param string $derivedDirectory
	 *        	Derived files directory
	 *
	 */
	public function initializeDerivedFileTest($basePath = null,
		$referenceDirectory = null, $derivedDirectory = null)
	{
		$this->derivedDataFiles = new \ArrayObject();
		$this->basePath = ($basePath ? $basePath : __DIR__ . '/..');
		$this->referenceDirectory = ($referenceDirectory ? $referenceDirectory : 'reference');
		$this->derivedDirectory = ($derivedDirectory ? $derivedDirectory : 'derived');
	}

	/**
	 * Remove all derived files generated by tests
	 *
	 * Should be called in TestCase desctructor or tearDown function
	 */
	public function cleanupDerivedFileTest()
	{
		if (count($this->derivedDataFiles))
		{
			foreach ($this->derivedDataFiles as $path => $persistent)
			{
				if ($persistent)
					continue;
				if (file_exists($path))
				{
					unlink($path);
				}
			}

			@rmdir($this->basePath . '/' . $this->derivedDirectory);
		}
	}

	/**
	 * Create file directory tree if not exists and asserts if the path exists
	 *
	 * @param string $filepath
	 *        	File path
	 * @param string $label
	 *        	Test message base
	 * @return boolean TRUE if directory was created successfully or already exists
	 */
	public function assertCreateFileDirectoryPath($filepath, $label)
	{
		$label = (\strlen($label) ? ': ' : '') .
			'Create file directory path';
		$result = $this->createFileDirectoryPath($filepath);
		$this->tryAssert('assertDirectoryExists', \dirname($filepath),
			$label);
		return $result;
	}

	/**
	 * Compare derived data agains existing reference file content
	 *
	 * @param mixed $data
	 *        	Derivede data generated by a test
	 * @param string $method
	 *        	Test method
	 * @param string $suffix
	 *        	Derived and reference file name suffix
	 * @param string $extension
	 *        	Derived and reference file extension
	 * @param string $label
	 *        	Test message
	 * @param string $eol
	 *        	Derived and reference file line endings
	 * @return string
	 */
	public function assertDataEqualsReferenceFile($data, $method,
		$suffix, $extension, $label = '', $eol = null)
	{
		$reference = $this->getReferenceFilename($method, $suffix,
			$extension);
		$derived = $this->buildFilename($this->derivedDirectory, $method,
			$suffix, $extension);
		if (\strlen($label) == 0)
			$label = \basename($derived);
		$label = (strlen($label) ? ($label . ': ') : '');

		if (!$this->assertCreateFileDirectoryPath($derived, $label))
			return false;
		$result = file_put_contents($derived, $data);

		$this->tryAssert('assertNotFalse', $result,
			$label . 'Write derived data');
		$this->tryAssert('assertFileExists', $derived,
			$label . 'Derived file exists');

		if ($result)
			$this->derivedDataFiles->offsetSet($derived, false);

		if (\is_file($reference))
		{
			$this->derivedDataFiles->offsetSet($derived, true);
			$this->tryAssert('assertEquals',
				$this->loadFile($reference, 'lf'),
				$this->convertEndOfLine($data, 'lf'), $label);
			$this->derivedDataFiles->offsetSet($derived, false);
		}
		else
		{
			if (!$this->assertCreateFileDirectoryPath($reference, $label))
				return false;

			$result = file_put_contents($reference, $data);
			$this->tryAssert('assertNotFalse', $result,
				$label . 'Write reference data to ' . $reference);
			$this->tryAssert('assertFileExists', $reference,
				$label . 'Reference file exists');
		}

		return $reference;
	}

	public function assertStreamEqualsReferenceFile($stream, $method,
		$suffix, $extension, $label = '', $eol = null)
	{
		$derived = $this->getDerivedFilename($method, $suffix,
			$extension);
		$reference = $this->getReferenceFilename($method, $suffix,
			$extension);
		$this->assertCreateFileDirectoryPath($reference,
			$label . ': Create reference file directory path');

		$meta = \stream_get_meta_data($stream);
		$position = -1;
		if ($meta['seekable'])
		{
			$position = \ftell($stream);
			\fseek($stream, 0);
		}

		if ($meta['wrapper_type'] == 'plainfile' &&
			($sr = \realpath($meta['uri'])) && \is_file($derived) &&
			(\realpath($derived) == $sr))
		{
			// Stream is the derived file
			// Compare with reference content

			$derivedData = \stream_get_contents($stream);
			$this->assertDataEqualsReferenceFile($data, $method, $suffix,
				$extension, $label, $eol);
		}
		else
		{
			// Copy stream to derived file and compare files
			$this->assertCreateFileDirectoryPath($derived,
				$label . ': Create derived file directory path');
			\file_put_contents($derived, $stream);
			if (!\file_exists($reference))
				\copy($derived, $reference);
			$this->tryAssert('assertFileEquals', $reference, $derived,
				$label . ': Compare files');
		}

		if ($meta['seekable'])
		{
			\fseek($stream, $position);
		}
	}

	/**
	 * Compare derived file with reference.
	 * If reference file does not exists yet, copy the content of derived file into it.
	 *
	 * @param string $method
	 *        	The method that invoke this assertion.
	 * @param string $suffix
	 *        	Derived and reference file name suffix
	 * @param string $extension
	 *        	Derived and reference file extension.
	 * @param string $label
	 * @param unknown $eol
	 */
	public function assertDerivedFileEqualsReferenceFile($method,
		$suffix, $extension, $label = '', $eol = null)
	{
		$reference = $this->getReferenceFilename($method, $suffix,
			$extension);
		$derived = $this->getDerivedFilename($method, $suffix,
			$extension);
		$this->tryAssert('assertFileExists', $derived,
			$label . ': Derived file exists');
		if (!\file_exists($reference))
		{
			$this->assertCreateFileDirectoryPath($reference,
				$label . ': Create reference file directory path');
			\copy($derived, $reference);
		}

		$this->tryAssert('assertFileEquals', $reference, $derived,
			$label);
	}

	/**
	 *
	 * @deprecated Ambiguous name. Use assertDataEqualsReferenceFile()
	 *
	 */
	public function assertDerivedFile($data, $method, $suffix,
		$extension, $label = '', $eol = null)
	{
		$this->assertDataEqualsReferenceFile($data, $method, $suffix,
			$extension, $label, $eol);
	}

	/**
	 *
	 * @param string $method
	 *        	The test method name. Generaly the <code>__METHOD__</code> constant.
	 * @param string $suffix
	 *        	File name suffix
	 * @param string $extension
	 *        	File extension
	 *
	 * @return string File full path
	 */
	public function getReferenceFilename($method, $suffix, $extension)
	{
		return $this->buildFilename($this->referenceDirectory, $method,
			$suffix, $extension);
	}

	/**
	 *
	 * @param string $method
	 *        	The test method name. Generaly the <code>__METHOD__</code> constant.
	 * @param string $suffix
	 *        	File name suffix
	 * @param string $extension
	 *        	File extension
	 *
	 * @return string File full path
	 */
	public function getDerivedFilename($method, $suffix, $extension)
	{
		return $this->buildFilename($this->derivedDirectory, $method,
			$suffix, $extension);
	}

	private function tryAssert (/* ... */)
	{
		$args = \func_get_args();
		$assertion = \array_shift($args);
		if (\method_exists($this, $assertion))
			\call_user_func_array([
				$this,
				$assertion
			], $args);
	}

	private function buildFilename($directory, $method, $suffix,
		$extension)
	{
		$pattern = '(?:(?:.*\\\\)?(?<class>.*?)(?:Test)*::)?(?:test)?(?<method>.*)$';
		$match = [];
		if (!\preg_match(chr(1) . $pattern . chr(1), $method, $match))
		{
			throw new \InvalidArgumentException('Invalid method name');
		}

		$method = $match['method'];
		$cls = $match['class'];
		$name = '';
		if (\strlen($cls))
			$name .= $cls . '_';
		$name .= $method;
		if (\is_string($suffix) && strlen($suffix))
			$name .= '_' .
				\preg_replace('/[^a-zA-Z0-9._-]/', '_', $suffix);

		$name .= '.' . $extension;
		$name = \preg_replace('/_+/', '_', $name);

		return $this->basePath . '/' . $directory . '/' . $name;
	}

	private function createFileDirectoryPath($filepath)
	{
		$path = \dirname($filepath);
		$result = true;
		if (!is_dir($path))
			$result = @mkdir($path, 0777, true);
		$this->tryAssert('assertTrue', $result,
			'Create directory ' . $path);
		return $result;
	}

	private function loadFile($file, $eol)
	{
		return $this->convertEndOfLine(file_get_contents($file), $eol);
	}

	private function convertEndOfLine($data, $eol)
	{
		$data = str_replace("\r\n", "\n", $data);
		$data = str_replace("\r", "\n", $data);

		if ($eol == 'crlf')
		{
			$data = str_replace("\n", "\r\n", $data);
		}
		elseif ($eol == 'cr')
		{
			$data = str_replace("\n", "\r",
				str_replace("\r\n", "\n", $data));
		}

		return $data;
	}

	/**
	 *
	 * @var array
	 */
	private $derivedDataFiles;

	private $referenceDirectory;

	private $derivedDirectory;

	/**
	 *
	 * @var string
	 */
	private $basePath;
}